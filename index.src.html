<h1>Secure Contexts</h1>
<pre class="metadata">
Status: ED
ED: https://w3c.github.io/webappsec-secure-contexts/
Shortname: powerful-features
TR: http://www.w3.org/TR/powerful-features/
Previous Version: http://www.w3.org/TR/2014/WD-powerful-features-20141204/
Level: 1
Editor: Mike West 56384, Google Inc., mkwst@google.com
Editor: Yan Zhu 75060, Yahoo! Inc., yzhu@yahoo-inc.com
Group: webappsec
Abstract:
  This specification defines "secure contexts", thereby allowing user agent
  implementers and specification authors to enable certain features only when
  certain minimum standards of authentication and confidentiality are met.
Version History: https://github.com/w3c/webappsec-secure-contexts/commits/master/index.src.html
!Participate: <a href="https://github.com/w3c/webappsec-secure-contexts/issues/new">File an issue</a> (<a href="https://github.com/w3c/webappsec-secure-contexts/issues">open issues</a>)
Indent: 2
Markup Shorthands: markdown on
Boilerplate: omit conformance, omit feedback-header
</pre>
<pre class="anchors">
urlPrefix: http://www.w3.org/TR/dom/; spec: DOM
  type: interface
    text: Document; url: interface-document
    text: Window; url: interface-window
urlPrefix: https://fetch.spec.whatwg.org/; spec: FETCH
  type: interface
    text: Response
  type: dfn
    text: basic fetch
urlPrefix: http://www.w3.org/TR/geolocation-API/; spec: GEOLOCATION-API
  type: method
    text: getCurrentPosition(); url: get-current-position
    text: watchPosition(); url: watch-position
urlPrefix: http://www.w3.org/TR/html5/; spec: HTML5
  type: dfn
    urlPrefix: embedded-content-0.html
      text: an iframe srcdoc document
    urlPrefix: browsers.html
      text: active document
      text: ancestor browsing context
      text: browsing context
      text: browsing context container
      text: creating a new Document object
      text: creator Document
      text: nested browsing context
      text: sandboxed origin browsing context flag
      text: sandboxing flag set
      text: top-level browsing context
      text: origin
      text: opaque identifier; url: origin
    urlPrefix: webappapis.html
      text: incumbent settings object
      text: settings object
      text: relevant settings object; url: relevant-settings-object-for-a-global-object
      text: responsible document
      text: global object
      text: script settings for browsing contexts
      text: document environment
      text: worker environment
  type: attribute
    urlPrefix: webstorage.html
      text: sessionStorage; for: WindowSessionStorage; url: the-sessionstorage-attribute
urlPrefix: http://www.w3.org/TR/mixed-content/; spec: MIX
  type: dfn
    text: a priori authenticated url
urlPrefix: http://www.w3.org/TR/service-workers/; spec: SERVICE-WORKERS
  type: interface
    text: ServiceWorker; url: service-worker-obj
urlPrefix: http://www.w3.org/2014/Process-20140801/; spec: W3C-PROCESS
  type: dfn
    text: modify a specification; url: rec-modify
urlPrefix: https://url.spec.whatwg.org/; spec: URL
  type: dfn
    text: origin of a url; url: concept-url-origin
    text: scheme; for: URL; url: concept-url-scheme
  type: interface
    text: URL
urlPrefix: https://html.spec.whatwg.org/multipage/; spec: HTML
  type: dfn
    urlPrefix: workers.html
      text: the worker's documents
      text: set up a worker environment settings object
    urlPrefix: webappapis.html
      text: creation URL
      text: HTTPS state
  type: constructor
    urlPrefix: workers.html
      text: SharedWorker(); url: dom-sharedworker
  type: interface
    urlPrefix: workers.html
      text: WorkerGlobalScope
      text: Worker
      text: SharedWorker
</pre>
<pre class="biblio">
{
  "BLUETOOTH": {
      "href": "https://webbluetoothcg.github.io/web-bluetooth/",
      "title": "Web Bluetooth",
      "publisher": "W3C",
      "authors": [ "Jeffrey Yasskin", "Vincent Scheib" ]
  },
  "COMCAST": {
      "href": "http://arstechnica.com/tech-policy/2014/09/why-comcasts-javascript-ad-injections-threaten-security-net-neutrality/",
      "title": "Comcast Wi-Fi serving self-promotional ads via JavaScript injection",
      "publisher": "Ars Technica",
      "authors": [ "David Kravets" ]
  },
  "CREDENTIAL-MANAGEMENT": {
    "authors": [ "Mike West" ],
    "href": "https://w3c.github.io/webappsec/specs/credentialmanagement/",
    "title": "Credential Management",
    "status": "ED",
    "publisher": "W3C"
  },
  "DISCOVERY": {
      "href": "https://dvcs.w3.org/hg/dap/raw-file/tip/discovery-api/Overview.html",
      "title": "Network Service Discovery",
      "authors": [ "Rich Tibbett" ],
      "publisher": "W3C"
  },
  "VERIZON": {
      "href": "http://adage.com/article/digital/verizon-target-mobile-subscribers-ads/293356/",
      "title": "Verizon looks to target its mobile subscribers with ads",
      "publisher": "Advertising Age",
      "authors": [ "Mark Bergen", "Alex Kantrowitz" ]
  },
  "POWERFUL-NEW-FEATURES": {
    "authors": [ "Chrome Security Team" ],
    "href": "https://www.chromium.org/Home/chromium-security/prefer-secure-origins-for-powerful-new-features",
    "title": "Prefer Secure Origins For Powerful New Features"
  },
  "W3C-PROCESS": {
    "authors": [ "Charles McCathie Nevile" ],
    "title": "World Wide Web Consortium Process Document",
    "href": "http://www.w3.org/2014/Process-20140801/",
    "publisher": "W3C"
  }
}
</pre>
<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
<section>
  <h2 id="intro">Introduction</h2>

  <em>This section is not normative.</em>

  As the web platform is extended to enable more useful and powerful
  applications, it becomes increasingly important to ensure that the features
  which enable those applications are enabled only in contexts which meet a minimum
  security level. This document describes threat models for feature abuse on the web
  (see [[#threat-models]]) and outlines normative requirements which should be
  incorporated into documents specifying new features (see
  [[#implementation-considerations]]).

  The most obvious of the requirements discussed here is that application code
  with access to sensitive or private data be delivered confidentially over
  authenticated channels that guarantee data integrity. Delivering code securely
  cannot ensure that an application will always meet a user's security and
  privacy requirements, but it is a necessary precondition.

  Less obviously, application code delivered over an authenticated and confidential
  channel isn't enough in and of itself to limit the use of powerful features by
  non-secure contexts. As [[#ancestors]] explains, cooperative frames can be
  abused to bypass otherwise solid restrictions on a feature. The algorithms
  defined below ensure that these bypasses are difficult and user-visible.

  The following examples summarize the normative text which follows:

  <style>
    .secure {
      fill: #8F8;
    }
    .non-secure {
      fill: #F88;
    }
    rect, circle {
      stroke-width: 2;
      stroke: black;
      fill-opacity: 0.75;
    }
    text {
      font-family: monospace;
    }
    text.rejection {
      fill: #F00;
      font-weight: 700;
      font-size: 2em;
    }
    g path {
      stroke-width: 2px;
      stroke: #666;
      fill-opacity: 0;
      stroke-dasharray: 5px, 5px;
    }
  </style>

  <h3 id="examples-top-level">Top-level Documents</h3>

  Top-level documents are secure on their own merits:

  <div class="example">
    <p><code>https://example.com/</code> opened in a <a>top-level browsing
    context</a> is a <a>secure context</a>, as it was delivered over
    an authenticated and encrypted channel.</p>

    <svg width="400" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="297" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
      </g>
    </svg>
  </div>

  <div class="example">
    <p><code>http://non-secure.example.com/</code> opened in a <a>top-level
    browsing context</a> pops open a new window containing
    <code>https://example.com/</code>. The former is not a <a>secure
    context</a>; the latter is a <a>secure context</a>, because it is a new
    top-level browsing context delivered over an authenticated and encrypted
    channel.</p>

    <svg width="400" height="400">
      <g transform="translate(10,10)">
        <rect height="175" width="297" y="0" x="0" class="non-secure" />
        <text transform="translate(10, 20)">http://non-secure.example.com/</text>
      </g>
      <g transform="translate(10,210)">
        <rect height="175" width="297" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
      </g>
      <g>
        <path d="M150, 87 C 200 75, 350 75, 150 287"></path>
      </g>
    </svg>
  </div>

  <h3 id="examples-framed">Framed Documents</h3>

  Framed documents can be <a>secure contexts</a> if they are delivered from
  <a>potentially trustworthy origins</a>, <em>and</em> if they're embedded
  in a <a>secure context</a>. That is:

  <div class="example">
    If <code>https://example.com/</code> opened in a <a>top-level browsing
    context</a> opens <code>https://sub.example.com/</code> in a frame, then
    both are <a>secure contexts</a>, as both were delivered over
    authenticated and encrypted channels.</p>

    <svg width="400" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(20, 50)">
          <rect height="105" width="250" y="0" x="0" class="secure" />
          <text transform="translate(10, 20)">https://sub.example.com/</text>
        </g>
      </g>
    </svg>
  </div>
  <div class="example">
    <p>If <code>https://example.com/</code> was somehow able to frame
    <code>http://non-secure.example.com/</code> (perhaps the user has
    overridden mixed content checking?), the top-level frame would remain
    secure, but the framed content is not</em> a secure context.</p>

    <svg width="400" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(20, 50)">
          <rect height="105" width="250" y="0" x="0" class="non-secure" />
          <text transform="translate(10, 20)">http://non-secure.example.com/</text>
        </g>
      </g>
    </svg>
  </div>
  <div class="example">
    <p>If, on the other hand, <code>https://example.com/</code> is framed
    inside of <code>http://non-secure.example.com/</code>, then it is
    <em>not</em> a secure context, as its ancestor is not delivered over an
    authenticated and encrypted channel.</p>

    <svg width="400" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="non-secure" />
        <text transform="translate(10, 20)">http://non-secure.example.com/</text>
        <g transform="translate(20, 50)">
          <rect height="105" width="250" y="0" x="0" class="non-secure" />
          <text transform="translate(10, 20)">https://example.com/</text>
        </g>
      </g>
    </svg>
  </div>

  <h3 id="examples-workers">Web Workers</h3>

  Dedicated Workers are similar in nature to framed documents. They're
  <a>secure contexts</a> when they're delivered from <a>potentially
  trustworthy origins</a>, only if their owner is itself a <a>secure
  context</a>:

  <div class="example">
    <p>If <code>https://example.com/</code> in a <a>top-level browsing
    context</a> runs <code>https://example.com/worker.js</code>, then
    both the document and the worker are <a>secure contexts</a>.</p>

    <svg width="600" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(400, 110)">
          <circle r="50" class="secure" />
          <text transform="translate(-75, -55)">https://example.com/worker.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
    </svg>
  </div>

  <div class="example">
    <p>If <code>http://non-secure.example.com/</code> in a <a>top-level browsing
    context</a> frames <code>https://example.com/</code>, which runs
    <code>https://example.com/worker.js</code>, then neither the framed document
    nor the worker are <a>secure contexts</a>.</p>

    <svg width="600" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="297" y="0" x="0" class="non-secure" />
        <text transform="translate(10, 20)">http://non-secure.example.com/</text>
        <g transform="translate(20, 50)">
          <rect height="105" width="250" y="0" x="0" class="non-secure" />
          <text transform="translate(10, 20)">https://example.com/</text>
        </g>
        <g transform="translate(400, 110)">
          <circle r="50" class="non-secure" />
          <text transform="translate(-75, -55)">https://example.com/worker.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
    </svg>
  </div>

  <h3 id="examples-shared-workers">Shared Workers</h3>

  Multiple contexts may attach to a Shared Worker. If a <a>secure context</a>
  creates a Shared Worker, then it is a <a>secure context</a>, and may only be
  attached to by other <a>secure contexts</a>. If a non-secure context creates
  a Shared Worker, then it is <em>not</em> a <a>secure context</a>, and may only
  be attached to by other non-secure contexts.

  <div class="example">
    <p>If <code>https://example.com/</code> in a <a>top-level browsing
    context</a> runs <code>https://example.com/worker.js</code> as a Shared
    Worker, then both the document and the worker are considered secure
    contexts.</p>

    <svg width="600" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(400, 110)">
          <circle r="50" class="secure" />
          <text transform="translate(-75, -55)">https://example.com/worker.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
    </svg>
  </div>

  <div class="example">
    <p><code>https://example.com/</code> in a different <a>top-level
    browsing context</a> (e.g. in a new window) is a secure context, so it may
    access the secure shared worker:</p>

    <svg width="600" height="400">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(400, 110)">
          <circle r="50" class="secure" />
          <text transform="translate(-75, -55)">https://example.com/worker.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
      <g transform="translate(10,200)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 -80"></path>
        </g>
      </g>
    </svg>
  </div>

  <div class="example">
    <p><code>https://example.com/</code> nested in
    <code>http://non-secure.example.com/</code> may not connect to the secure
    worker, as it is not a secure context.</p>

    <svg width="600" height="400">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(400, 110)">
          <circle r="50" class="secure" />
          <text transform="translate(-75, -55)">https://example.com/worker.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
      <g transform="translate(10,200)">
        <rect height="175" width="300" y="0" x="0" class="non-secure" />
        <text transform="translate(10, 20)">http://non-secure.example.com/</text>
        <g transform="translate(20, 50)">
          <rect height="105" width="250" y="0" x="0" class="non-secure" />
          <text transform="translate(10, 20)">https://example.com/</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 20"></path>
          <text transform="translate(405, 20)" class="rejection">X</text>
        </g>
      </g>
    </svg>

  </div>

  <div class="example">
    <p>Likewise, if <code>https://example.com/</code> nested in
    <code>http://non-secure.example.com/</code> runs
    <code>https://example.com/worker.js</code> as a Shared
    Worker, then both the document and the worker are considered non-secure.</p>

    <svg width="600" height="400">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="non-secure" />
        <text transform="translate(10, 20)">http://non-secure.example.com/</text>
        <g transform="translate(20, 50)">
          <rect height="105" width="250" y="0" x="0" class="non-secure" />
          <text transform="translate(10, 20)">https://example.com/</text>
        </g>
        <g transform="translate(400, 110)">
          <circle r="50" class="non-secure" />
          <text transform="translate(-75, -55)">https://example.com/worker.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
      <g transform="translate(10,200)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 20"></path>
          <text transform="translate(405, 20)" class="rejection">X</text>
        </g>
      </g>
    </svg>
  </div>

  <h3 id="examples-service-workers">Service Workers</h3>

  Service Workers are always <a>secure contexts</a>. Only <a>secure contexts</a>
  may register them, and they may only have clients which are <a>secure
  contexts</a>.

  <div class="example">
    <p>If <code>https://example.com/</code> in a <a>top-level browsing
    context</a> registers <code>https://example.com/service.js</code>,
    then both the document and the Service Worker are considered secure
    contexts.</p>

    <svg width="600" height="200">
      <g transform="translate(10,10)">
        <rect height="175" width="300" y="0" x="0" class="secure" />
        <text transform="translate(10, 20)">https://example.com/</text>
        <g transform="translate(400, 110)">
          <circle r="50" class="secure" />
          <text transform="translate(-75, -55)">https://example.com/service.js</text>
        </g>
        <g>
          <path d="M150, 87 C 200 75, 350 75, 405 110"></path>
        </g>
      </g>
    </svg>
  </div>
</section>

<section>
  <h2 id="framework">Framework</h2>

  A <a>settings object</a> is considered a <dfn export>secure context</dfn> if
  the algorithm in [[#settings-object]] returns "`Secure`". The <a>settings
  object</a> is otherwise <dfn export lt="non-secure context">non-secure</dfn>.

  Likewise, a <a>global object</a> is considered a <a>secure context</a> if its
  <a>relevant settings object</a> is a <a>secure context</a>.

  <h3 id="monkey-patching">Modifications to HTML</h3>

  <h4 id="monkey-patching-shared-workers">Shared Workers</h4>

  The {{SharedWorker()}} constructor will throw a `SecurtyError` exception if
  a <a>secure context</a> attempts to attach to an Worker which is not a
  <a>secure context</a>, and if a non-secure context attempts to attach to a
  Worker which is a <a>secure context</a>. The constructor is modified as
  follows:

  1.  As the first substep of the {{SharedWorker()}} constructor's current step
      7.7 ("If <var>worker global scope</var> is not `null`, then run these
      steps:"), run the following step:

      1.  If the result of executing [[#settings-object]] on the <a>incumbent
          settings object</a> does not match the result of executing the same
          algorithm on <var>worker global scope</var>'s <a>relevant settings
          object</a>, then throw a `SecurityError` exception, and abort
          these steps.

  <h4 id="monkey-patching-global-object">Feature Detection</h4>

  To determine whether a context is capable of making use of features which
  require <a>secure contexts</a>, a simple boolean attribute is added to the
  global object:

  <pre class="idl">
    partial interface Window {
      readonly attribute boolean isSecureContext;
    };

    partial interface WorkerGlobalScope {
      readonly attribute boolean isSecureContext;
    };
  </pre>

  Both {{Window}}'s {{Window/isSecureContext}} and {{WorkerGlobalScope}}'s
  {{WorkerGlobalScope/isSecureContext}} attributes' getters return
  <code>true</code> if the <a>relevant settings object</a> for the getter's
  <a>global object</a> is a <a>secure context</a>, and <code>false</code>
  otherwise.
</section>

<section>
  <h2 id="algorithms">Algorithms</h2>

  <h3 id="settings-object">
    Is |settings object| a secure context?
  </h3>

  Given a <a>settings object</a> (|settings object|), this algorithm returns
  "`Secure`" if the object represents a context which the user agent obtained
  via a secure channel, and "`Not Secure`" otherwise.

  1.  Let |ancestors| be an empty list.

  2.  If |settings object|'s <a>global object</a> is a
      {{WorkerGlobalScope}}, then:

      1.  Add |settings object| to |ancestors|.

      2.  For each {{Document}} (|document|) in |settings object|'s <a>global
          object</a>'s list of <a>the worker's `Documents`</a>:

          1.  Add each item in the result of executing [[#gather-ancestors]] on
              |document| to |ancestors|.

  3.  Otherwise, |settings object|'s <a>global object</a> is a {{Window}}, so:

      1.  Add each item in the result of executing [[#gather-ancestors]] on
          |settings object|'s <a>responsible document</a> to |ancestors|.

  4.  For each |ancestor settings object| in |ancestors|:

      1.  If |ancestor settings object|'s <a>HTTPS state</a> is "`modern`", skip
          to the next |ancestor settings object|.

          <div class="note">
            Most of the time, this check will be enough to determine whether
            a particular context was securely delivered. Documents delivered over
            TLS will have the flag set, and `srcdoc` `Document`s inherit their
            ancestor's flag (as do other kinds of requests which inherit their
            requestor's origin: see the <a>basic fetch</a> algorithm for details
            on some of these [[FETCH]]).
          
            We'll only continue past this check when dealing with resources
            delivered from "trustworthy" but unauthenticated locations like
            `http://127.0.0.1/`.
          </div>

      2.  Let |origin| be |ancestor settings object|'s <a>origin</a>.

      3.  If |origin| is an <a>opaque identifier</a>, set |origin| to the
          <a lt="origin of a url">origin</a> of |settings object|'s <a>creation
          URL</a>.

          Note: We use the origin of the URL here in order to allow sandboxed
          context to remain secure (as sandboxing is a strict reduction in the
          context's capabilities, and therefore to the risk it poses). This
          covers scenarios such as `<iframe sandbox src="http://localhost/">`.

      4.  If the result of executing the [[#is-origin-trustworthy]] algorithm
          on |origin| is <strong>not</strong> `Potentially
          Trustworthy`, then return "`Not Secure`".

  5.  Return "`Secure`".

  <h3 id="is-origin-trustworthy">
    Is <var>origin</var> potentially trustworthy?
  </h3>

  A <dfn export>potentially trustworthy origin</dfn> is one which a user agent
  can generally trust as delivering data securely.

  This algorithms considers certain hosts, scheme, and origins as potentially
  trustworthy, even though they might not be authenticated and encrypted in the
  traditional sense. In particular, the user agent SHOULD treat `file` URLs and
  URLs with hostnames names equivalent to `localhost` as potentially
  trustworthy. In principle the user agent could treat local files and local web
  servers as untrustworthy, but, <em>given the information that is available to
  the user agent at runtime</em>, the resources appear to have been transported
  securely from disk to the user agent. Additionally, treating such resources as
  potentially trustworthy is convenient for developers building an application
  before deploying it to the public.

  This developer-friendlyness is not without risk, however. User agents which
  prioritize security over such niceties MAY choose to more strictly assign
  trust in a way which excludes `localhost.` and `file`.

  On the other hand, the user agent MAY choose to extend this trust to other,
  vendor-specific URL schemes like `app:` or `chrome-extension:` which it can
  determine <i lang="la">a priori</i> to be trusted (see
  [[#packaged-applications]] for detail).

  Given an <a>origin</a> (|origin|), the following algorithm returns
  "`Potentially Trustworthy`" or "`Not Trustworthy`" as appropriate.

  1.  If |origin| is an <a>opaque identifier</a>, return "`Not Trustworthy`".

  2.  If |origin|'s `scheme` is either "`https`" or "`wss`", return
      "`Potentially Trustworthy`".

      Note: This is meant to be analog to the <a><i lang="la">a priori</i>
      authenticated URL</a> concept in [[MIX]].

      Note: The origin of `blob:` and `filesystem:` URLs is the origin of the
      context in which they were created. Therefore, blobs created in a
      trustworthy origin will themselves be potentially trustworthy. The origin
      of `data:` and `javascript:` URLs, on the other hand, is an <a>opaque
      identifier</a>, which will not be considered potentially trustworthy.

  3.  If |origin|'s `host` component is or falls within "`localhost.`"
      [[!RFC6761]], return "`Potentially Trustworthy`".

  4.  If |origin|'s `host` component matches one of the CIDR notations
      `127.0.0.0/8` or `::1/128` [[!RFC4632]], return "`Potentially
      Trustworthy`".

  5.  If |origin|'s `scheme` component is `file`, return "`Potentially
      Trustworthy`".

  6.  If |origin|'s `scheme` component is one which the user agent considers to
      be authenticated, return "`Potentially Trustworthy`".

      Note: See [[#packaged-applications]] for detail here.

  7.  If |origin| has been configured as a trustworthy origin, return
      `Potentially Trustworthy`".

      Note: See [[#development-environments]] for detail here.

  8.  Return "`Not Trusted`".

  <h3 id="gather-ancestors">
    Gather <var>document</var>'s relevant ancestors
  </h3>

  Given a {{Document}} (<var>document</var>), this algorithm returns a list of
  <a>settings objects</a> which ought to be considered when determining whether
  or not <var>document</var> is a <a>secure context</a>.

  1.  Let <var>ancestors</var> be an empty list.
 
  2.  If <var>document</var> is not <a>an IFrame `srcdoc` `Document`</a>, add
      |document|'s <a>relevant settings object</a> to |ancestors|.

  2.  While <var>document</var> has a <a>creator <code>Document</code></a>
      <var>creator</var>:

      1.  If <var>creator</var>'s <a>browsing context</a> is an <a>ancestor
          browsing context</a> of <var>document</var>:

          1.  Insert <var>creator</var>'s <a>relevant settings object</a> into
              <var>ancestors</var>, unless <var>creator</var> is <a>an IFrame
              `srcdoc` `Document`</a>.

          2.  Let <var>document</var> be <var>creator</var>.

      2.  Otherwise, exit this loop.

  3.  Return <var>ancestors</var>.

  Note: When gathering a {{Document}}'s ancestors, we walk the browsing context
  creation document chain, but stop when that chain spans across more than one
  {{Window}}. That is, a newly opened window is evaluated on its own merits,
  without regard for the status of the opener.
</section>

<section>
  <h2 id="threat-models-risks">
    Threat models and risks
  </h2>

  <em>This section is non-normative.</em>

  <h3 id="threat-models">Threat Models</h3>

  Granting permissions to unauthenticated origins is, in the presence of a
  network attacker, equivalent to granting the permissions to any origin. The
  state of the Internet is such that we must indeed assume that a network
  attacker is present. Generally, network attackers fall into 2 classes:
  passive and active.

  <h4 id="threat-passive">Passive Network Attacker</h4>

  A "Passive Network Attacker" is a party who is able to observe traffic
  flows but who lacks the ability or chooses not to modify traffic at
  the layers which this specification is concerned with.

  Surveillance of networks in this manner "subverts the intent of communicating
  parties without the agreement of these parties" and one "cannot defend against
  the most nefarious actors while allowing monitoring by other actors no matter
  how benevolent some might consider them to be." [[RFC7258]] Therefore, the
  algorithms defined in this document require mechanisms that provide for the
  privacy of data at the application layer, not simply integrity.

  <h4 id="threat-active">Active Network Attacker</h4>

  An "Active Network Attacker" has all the capabilities of a "Passive Network
  Attacker" and is additionally able to modify, block or replay any data
  transiting the network.  These capabilities are available to potential
  adversaries at many levels of capability, from compromised devices offering
  or simply participating in public wireless networks, to Internet Service
  Providers indirectly introducing security and privacy vulnerabilities while
  manipulating traffic for financial gain ([[VERIZON]] and [[COMCAST]] are
  recent examples), to parties with direct intent to compromise security or
  privacy who are able to target individual users, organizations or even
  entire populations.

  <h3 id="ancestors">Ancestral Risk</h3>

  The [[#settings-object]] algorithm walks through all the ancestors of a
  particular context in order to determine whether or not the context itself is
  secure. Why wouldn't we consider a securely-delivered document in an
  <{iframe}> to be secure, in and of itself?

  The short answer is that this model would enable abuse. Chrome's
  implementation of [[WEBCRYPTOAPI]] was an early experiment in locking APIs to
  secure contexts, and it does not walk through a context's ancestors. The
  assumption was that locking the API to a resouce which was itself delivered
  securely would be enough to ensure secure usage. The result, however, was
  that entities like Netflix built <{iframe}>- and `postMessage()`-based shims
  that exposed the API to non-secure contexts. The restriction was little more
  than a speed-bump, slowing down non-secure access to the API, but completely
  ineffective in preventing such access.

  While the algorithms in this document do not perfectly isolate non-secure
  contexts from <a>secure contexts</a> (as discussed in [[#isolation]]), the
  ancestor checks provide a fairly robust protection for the guarantees of
  authentication, confidentiality, and integrity that such contexts ought to
  ptovide.

  <h3 id="threat-risks">Risks associated with non-secure contexts</h3>

  Certain web platform features that have a distinct impact on a user's
  security or privacy should be available for use only in <a>secure
  contexts</a> in order to defend against the threats above. Features
  available in non-secure contexts risk exposing these capabilities to
  network attackers:

  <ol>
    <li>
      The ability to read and modify sensitive data (personally-identifying
      information, credentials, payment instruments, and so on).
      [[CREDENTIAL-MANAGEMENT]] is an example of an API that handles sensitive
      data.
    </li>
    <li>
      The ability to read and modify input from sensors on a user's device
      (camera, microphone, and GPS being particularly noteworthy, but
      certainly including less obviously dangerous sensors like the
      accelerometer). [[GEOLOCATION-API]] and [[MEDIACAPTURE-STREAMS]] are
      historical examples of features that use sensor input.
    </li>
    <li>
      The ability to access information about other devices to which a user has
      access. [[DISCOVERY]] and [[BLUETOOTH]] are good examples.
    </li>
    <li>
      The ability to track users using temporary or persistent identifiers,
      including identifiers which reset themselves after some period of time
      (e.g. {{sessionStorage}}), identifiers the user can manually reset
      (e.g. [[ENCRYPTED-MEDIA]], Cookies [[RFC6265]], and [[IndexedDB]]),
      as well as identifying hardware features the user can't easily reset.
    </li>
    <li>
      The ability to introduce some state for an origin which persists across
      browsing sessions. [[SERVICE-WORKERS]] is a great example.
    </li>
    <li>
      The ability to manipulate a user agent's native UI in some way which
      removes, obscures, or manipulates details relevant to a user's
      understanding of their context. [[FULLSCREEN]] is a good example.
    </li>
    <li>
      The ability to introduce some functionality for which user permission will
      be required.
    </li>
  </ol>

  This list is non-exhaustive, but should give you a feel for the types of
  risks we should consider when writing or implementing specifications.

  Note: While restricting a feature itself to <a>secure contexts</a> is
  critical, we ought not forget that facilities that carry such information
  (such as new network access mechanisms, or other generic functions with access
  to network data) are equally sensitive.
</section>

<section>
  <h2 id="security-considerations">Security Considerations</h2>

  <h3 id="isolation">Incomplete Isolation</h3>

  The <a>secure context</a> definition in this document does not completely
  isolate a "secure" view on an origin from a "non-secure" view on the same
  origin. That is, a developer who is actively working to bypass the secure
  context restriction on a particular API will be able to create a
  `postMessage`-based shim if they're willing to pop up a new window
  and rely on its persistence (as the new window will be a new top-level
  browsing context, and will be evaluated without regard for the opener's
  state).

  More esoteric exfiltration methods will be available as well, ranging from
  shared `localStorage` and related `storage` events to `window.name` tricks.
</section>

<section>
  <h2 id="implementation-considerations">Implementation Considerations</h2>

  <h3 id="packaged-applications">Packaged Applications</h3>

  A user agent that support packaged applications MAY whitelist specific URL
  schemes whose contents are authenticated by the user agent. For example,
  FirefoxOS application resources are referred to by a URL whose
  <a for="URL">scheme</a> component is `app:`. Likewise, Chrome's extensions
  and apps live on `chrome-extension:` schemes. These could reasonably be
  considered trusted origins.

  <h3 id="development-environments">Development Environments</h3>

  In order to support developers who run staging servers on non-loopback hosts,
  the user agent MAY allow users to configure specific sets of origins as
  trustworthy, even though [[#is-origin-trustworthy]] would normally return
  `Not Trusted`.

  <h3 id="new">Restricting New Features</h3>

  <em>This section is non-normative.</em>

  When writing a specification for new features, we recommend that authors
  and editors guard sensitive APIs with checks against <a>secure contexts</a>.
  For example, something like the following might be a good approach:

  <div class="example">
    <ol>
      <li>
        If the <a>incumbent settings object</a> is <em>not</em> a <a>secure
        context</a>, then:

        <ol>
          <li>
            [<i>insert something appropriate here: perhaps a Promise could be
            rejected with a `SecurityError`, an error callback could be called,
            a permission request denied, etc.</i>].
          </li>
        </ol>
      </li>
    </ol>
  </div>

  <h3 id="legacy">Restricting Legacy Features</h3>

  <em>This section is non-normative.</em>

  The list above clearly includes some existing functionality that is currently
  available to the web over non-secure channels. We recommend that such legacy
  functionality begin requiring a <a>secure context</a> as quickly as is
  reasonably possible.

  1.  If such a feature is not widely implemented, we recommend that the
      specification be immediately
      <a lt="modify a specification">modified</a> to include a restriction
      to <a>secure contexts</a>.

  2.  If such a feature is widely implemented, but not yet in wide use, we
      recommend that it be quickly restricted to <a>secure contexts</a> by
      adding a check as described in [[#new]] to existing implementations, and
      <a lt="modify a specification">modifying the specification</a>
      accordingly.

  3.  If such a feature is in wide use, we recommend that the existing
      functionality be deprecated; the specification should be
      <a lt="modify a specification">modified</a> to note that it does not
      conform to the restrictions outlined in this document, and a plan should
      be developed to both offer a conformant version of the feature and to
      migrate existing users into that new version.

  <h4 id="legacy-example">Example: Geolocation</h4>

  The [[GEOLOCATION-API]] is a good concrete example of such a feature; it is
  widely implemented and used on a large number of non-secure sites. A reasonable
  path forward might look like this:

  1.  <a lt="modify a specification">Modify</a> the specification to include
      checks against <a>secure context</a> before executing the algorithms for
      {{getCurrentPosition()}} and {{watchPosition()}}.

      If the <a>incumbent settings object</a> is not a <a>secure context</a>,
      then the algorithm should be aborted, and the `errorCallback`
      invoked with a `code` of `PERMISSION_DENIED`.

  2.  The user agent should announce clear intentions to disable the API for
      non-secure contexts on a specific date, and warn developers accordingly
      (via console messages, for example).

  3.  Leading up to the flag day, the user agent should announce a deprecation
      schedule to ensure both that site authors recognize the need to modify
      their code before it simply stops working altogether, and to protect
      users in the meantime. Such a plan might include any or all of:

      1.  Disallowing persistent permission grants to non-secure origins

      2.  Coarsening the accuracy of the API for non-secure origins (perhaps
          consistently returning city-level data rather than high-accuracy
          data)

      3.  UI modifications to inform users and site authors of the risk
</section>

<!--
   ███     ██████  ██    ██ ██    ██  ███████  ██      ██ ██       ████████ ████████   ██████   ████████ ██     ██ ████████ ██    ██ ████████  ██████
  ██ ██   ██    ██ ██   ██  ███   ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ███   ███ ██       ███   ██    ██    ██    ██
 ██   ██  ██       ██  ██   ████  ██ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██        ██       ████ ████ ██       ████  ██    ██    ██
██     ██ ██       █████    ██ ██ ██ ██     ██ ██  ██  ██ ██       ██████   ██     ██ ██   ████ ██████   ██ ███ ██ ██████   ██ ██ ██    ██     ██████
█████████ ██       ██  ██   ██  ████ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ██     ██ ██       ██  ████    ██          ██
██     ██ ██    ██ ██   ██  ██   ███ ██     ██ ██  ██  ██ ██       ██       ██     ██ ██    ██  ██       ██     ██ ██       ██   ███    ██    ██    ██
██     ██  ██████  ██    ██ ██    ██  ███████   ███  ███  ████████ ████████ ████████   ██████   ████████ ██     ██ ████████ ██    ██    ██     ██████
-->
<section>
  <h2 id="acknowledgements">Acknowledgements</h2>

  This document is largely based on the Chrome Security team's work on
  [[POWERFUL-NEW-FEATURES]]. Chris Palmer, Ryan Sleevi, and David Dorwin have
  been particularly engaged. Anne van Kesteren, Boris Zbarsky, and Henri Sivonen
  have also provided very helpful feedback.
</section>
